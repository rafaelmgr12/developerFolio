{"status":"ok","feed":{"url":"https://medium.com/feed/@rgribeiro","title":"Stories by Rafael Ribeiro on Medium","link":"https://medium.com/@rgribeiro?source=rss-303f8669abf9------2","author":"","description":"Stories by Rafael Ribeiro on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*kENQbV6PMDnIwa823jhf-Q.png"},"items":[{"title":"Como encontrar elementos duplicados em uma Lista?","pubDate":"2022-07-12 11:12:44","link":"https://medium.com/@rgribeiro/como-achar-elementos-duplicados-em-uma-lista-69ead8889a2f?source=rss-303f8669abf9------2","guid":"https://medium.com/p/69ead8889a2f","author":"Rafael Ribeiro","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*GlBRiPadpVQv9xqoLMfU1A.png","description":"\n<p>L\u00f3gica \u00e9 requisito para todo programador, e para continuar me aperfei\u00e7oando, uso algumas plataformas online como a HackerRank e LeetCode. E essas plataformas t\u00eam desafios de programa\u00e7\u00e3o para todos os n\u00edveis. Dessa forma \u00e9 poss\u00edvel treinar l\u00f3gica como tamb\u00e9m estrutura de dados como ferramentas para resolu\u00e7\u00e3o do\u00a0mesmo.</p>\n<h3>Problema</h3>\n<p>Dito isso, durante um exerc\u00edcio achei que seria relevante compartilhar. Num primeiro momento ele parece bem simples. O enunciado \u00e9 o seguinte.</p>\n<blockquote><em>Dado um vetor de inteiros, nums, contendo n+1 inteiros onde cada inteiro est\u00e1 no intervalo [1,n]\u00a0. Existe apenas um n\u00famero repetido em nums, retorne esse n\u00famero\u00a0repetido</em></blockquote>\n<p>As restri\u00e7\u00f5es s\u00e3o</p>\n<ul>\n<li>1\u2264 n\u226410\u2075</li>\n<li>nums.length == n +\u00a01</li>\n<li>1 &lt;= nums[i] &lt;=\u00a0n</li>\n<li>Todos os inteiros em nums aparecem apenas uma vez, exceto precisamente um inteiro que aparece duas ou mais\u00a0vezes.</li>\n</ul>\n<p>A obrigatoriedade de conter um inteiro repetido vem do<strong> Pigeonhole principle</strong>. \u00c9 um princ\u00edpio bem conhecido na matem\u00e1tica, voc\u00eas podem consultar isso facilmente na internet. \u00c9 recomend\u00e1vel olhar a prova, \u00e9 bem interessante como faz alus\u00e3o \u00e0 v\u00e1rios problemas reais.</p>\n<p>Bem, o que dificulta o problema \u00e9 restri\u00e7\u00e3o na solu\u00e7\u00e3o que\u00a0\u00e9:</p>\n<blockquote><em>Voc\u00ea deve resolver o problema sem modificar o vetor nums e usa apenas espa\u00e7o extra constante.</em></blockquote>\n<p>Como pode ser visto essa restri\u00e7\u00e3o torna o problema dif\u00edcil, tendo em vista que n\u00e3o \u00e9 poss\u00edvel usar nenhum estrutura de dados e tamb\u00e9m n\u00e3o \u00e9 poss\u00edvel modificar o vetor\u00a0nums.</p>\n<h3>Solu\u00e7\u00e3o</h3>\n<p>Esse \u00e9 um problema cl\u00e1ssico, com duas solu\u00e7\u00f5es poss\u00edveis. A primeira que usarei, estarei ignorando a restri\u00e7\u00e3o de modifica\u00e7\u00e3o do problema. Essa forma \u00e9 apenas um come\u00e7o para gente pensar em como resolver esse problema.</p>\n<p>Bem, para come\u00e7ar usarei uma abordagem bem simples, mas que resolveria esse problema se n\u00e3o houvesse restri\u00e7\u00e3o na\u00a0solu\u00e7\u00e3o.</p>\n<p>A ideia \u00e9 a seguinte, a primeiro momento nosso vetor tem valores espalhados e n\u00e3o segue uma ordem espec\u00edfica. Mas e se fizessemos a ordena\u00e7\u00e3o desse vetor? Os valores duplicados estariam perto um do\u00a0outro.</p>\n<p>Temos que:</p>\n<ol>\n<li>Ordenar o vetor\u00a0nums;</li>\n<li>Executar um loop para examinar os elementos e se o elemento subsequente for igual ao antecessor temos o valor duplicado;</li>\n<li>Retorna o primeiro n\u00famero que \u00e9 igual ao seu antecessor.</li>\n</ol>\n<p>O c\u00f3digo em python fica da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        nums.sort()<br>        for i in range(1, len(nums)):<br>            if nums[i] == nums[i-1]:<br>                return nums[i]</pre>\n<p>Essa solu\u00e7\u00e3o j\u00e1 seria suficiente, pois se analisarmos a Complexidade ter\u00edamos o seguinte:</p>\n<ul><li>\n<strong>Complexidade de tempo\u00a0:</strong> O(n log\u00a0n)</li></ul>\n<p>Ordena\u00e7\u00e3o leva O(n log n). E seguindo fazer uma loop linear para avaliar os elementos do vetor assim resultando, O(n log n) + O(n) = O(n log\u00a0n)</p>\n<ul><li>\n<strong>Complexidade no espa\u00e7o</strong>: <em>O(logn)</em> or\u00a0<em>O(n)</em>\n</li></ul>\n<p>A complexidade do espa\u00e7o do algoritmo de ordena\u00e7\u00e3o depende da implementa\u00e7\u00e3o de cada linguagem de programa\u00e7\u00e3o:</p>\n<ul>\n<li>Java, Arrays.sort() \u00e9 implementado usando uma variante do algoritmo Quick Sort, que tem uma complexidade de espa\u00e7o de O(log\u00a0n)</li>\n<li>Em C++, a fun\u00e7\u00e3o sort() fornecida pelo STL usa um h\u00edbrido de Quick Sort, Heap Sort e Insertion Sort, com uma complexidade de espa\u00e7o no pior caso de O(log\u00a0n)</li>\n<li>Em Python, a fun\u00e7\u00e3o sort() \u00e9 implementada usando o algoritmo Timsort, que tem uma complexidade de espa\u00e7o de pior caso de\u00a0O(n)</li>\n</ul>\n<p>A restri\u00e7\u00e3o no espa\u00e7o tamb\u00e9m se tonar um problema, j\u00e1 que poder\u00edamos usar um HashMap para contar valores os valores e armazen\u00e1-los. Assim temos que pensar um pouco mais para assim conseguir pensar numa solu\u00e7\u00e3o que siga essa restri\u00e7\u00e3o.</p>\n<h3>Detec\u00e7\u00e3o C\u00edclica</h3>\n<p>Podemos usar um algoritmo de detec\u00e7\u00e3o c\u00edclica. A ide\u00e1 \u00e9 pensar que esse vetor possar ser tratado como uma lista encadeada e como temos um valor repetido esse valor far\u00e1 a lista conter um ciclo. Pode ser observado na figura abaixo a\u00a0ideia.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GlBRiPadpVQv9xqoLMfU1A.png\"></figure><p>Como pode ser visto o valor duplicado em nosso vetor se tornar a entrada em nosso ciclo. A ideia \u00e9 reduzir esse problema a <a href=\"https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem\">Cycle Detection</a> ou <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/\">Linked List Cycle\u00a0II</a>.</p>\n<p>Podemos aumentar o tamanho do vetor nums para ilustrar melhor nosso problema.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oxz5lWqerwMRdDqIcSi36Q.png\"></figure><h3>Floyd\u2019s Hare and\u00a0Tortoise</h3>\n<p>\u00c9 um algoritmo de ponteiro que usa apenas dois ponteiros, que se movem pela sequ\u00eancia em velocidades diferentes. Tamb\u00e9m \u00e9 chamado de \u201calgoritmo da tartaruga e da lebre\u201d, aludindo \u00e0 f\u00e1bula de Esopo, A tartaruga e a\u00a0lebre.</p>\n<p>Para entender de maneira clara dividiremos o procedimento em duas partes. Assim, trazendo ela para o nosso problema tem o seguinte.</p>\n<p><strong>Primeira Fase:</strong></p>\n<p>hare = nums[nums[hare]] \u00e9 duas vezes mais r\u00e1pido que tortoise = nums[tortoise]. Como a lebre anda r\u00e1pido, seria a primeira a entrar no ciclo e correr ao redor do ciclo. Em algum momento, a tartaruga tamb\u00e9m entra no ciclo e, como est\u00e1 se movendo mais devagar, a lebre alcan\u00e7a a tartaruga em algum ponto de interse\u00e7\u00e3o. Agora a fase 1 acabou e a tartaruga perdeu.</p>\n<blockquote><em>Observe que o ponto de interse\u00e7\u00e3o n\u00e3o \u00e9 a entrada do ciclo no caso\u00a0geral.</em></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OYJE40t-qH22Of2_.png\"></figure><p>\u00c9 poss\u00edvel calcular a interse\u00e7\u00e3o, basta notar que a lebre(hare) percorreu o dobro da tartaruga(tortoise), ou seja, 2d(tortoise) =\u00a0d(hare):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/211/0*tWsxGp0z0MuS8gM1\"></figure><p>Onde n \u00e9 um n\u00famero inteiro. \u00c9 importante notar que esse passo \u00e9 crucial e prova que algoritmo de Floyd funciona. Visto que estamos calculando a dist\u00e2ncia do primeiro elemento da lista at\u00e9 o ponto da interse\u00e7\u00e3o, essa conta se tonar algo indispens\u00e1vel para implementar a pr\u00f3xima fase do algoritmo.</p>\n<p><strong>Segunda Fase:</strong></p>\n<p>Nessa fase daremos a tartaruga uma segunda chance, ou seja, diminuiremos a velocidade da lebre, de modo que agora ela se mova na velocidade da tartaruga: tortoise = nums[tortoise]\u00a0,hare = nums[hare]. A tartaruga est\u00e1 de volta \u00e0 posi\u00e7\u00e3o inicial e a lebre parte do ponto de interse\u00e7\u00e3o.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*p2uHTOH37bK6ma7QKYdw9w.png\"></figure><p>Mostraremos que desta vez eles se encontram na entrada do ciclo ap\u00f3s F\u00a0passos.</p>\n<ul>\n<li>A tartaruga come\u00e7ou em zero, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s o F passos \u00e9\u00a0F.</li>\n<li>A lebre come\u00e7ou no ponto de interse\u00e7\u00e3o F + a = nC, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s F passos \u00e9 nC+F, o mesmo ponto que\u00a0F.</li>\n<li>Assim, a tartaruga e a lebre (desacelerada) se encontrar\u00e3o na entrada do\u00a0ciclo.</li>\n</ul>\n<p>A imagem abaixo mostra o que acontece durante todas as\u00a0fases.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/1*09n9E-RUgjCd6uIRzue7Gg.gif\"></figure><p>O c\u00f3digo em python \u00e9 escrito da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        # Ache o ponto de interse\u00e7\u00e3o dos ponteiros<br>        tortoise = hare = nums[0]<br>        while True:<br>            tortoise = nums[tortoise]<br>            hare = nums[nums[hare]]<br>            if tortoise == hare:<br>                break<br><br>        # Ache o a entrada dentro do ciclo.<br>        tortoise = nums[0]<br>        while tortoise != hare:<br>            tortoise = nums[tortoise]<br>            hare = nums[hare]<br><br>        return hare</pre>\n<ul>\n<li>\n<strong>Complexidade de tempo:</strong>\u00a0O(n)</li>\n<li>\n<strong>Complexidade no espa\u00e7o</strong>:\u00a0<em>O(1)</em>\n</li>\n</ul>\n<p>Aplicando esse m\u00e9todo temos uma solu\u00e7\u00e3o bem elegante e otimizada do nosso problema. Essa categoria de problema \u00e9 aquela que se torna trivial quando se resolve, mas num primeiro momento n\u00e3o \u00e9 intuitivo reduzi-lo em um problema de listas encadeada c\u00edclicas.</p>\n<p>Se houver d\u00favida ainda, \u00e9 poss\u00edvel printar no console os valores dos ponteiros tortoise e hare, para melhorar a visualiza\u00e7\u00e3o.</p>\n<h3>Referencias</h3>\n<ul>\n<li>Explica\u00e7\u00e3o em video pode ser vista\u00a0<a href=\"https://www.youtube.com/watch?v=wjYnzkAhcNk\">aqui</a>.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cycle_detection\">Wikipedia</a></li>\n<li>Problema pode se encontrado <a href=\"https://leetcode.com/problems/find-the-duplicate-number/\">aqui</a>.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=69ead8889a2f\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>L\u00f3gica \u00e9 requisito para todo programador, e para continuar me aperfei\u00e7oando, uso algumas plataformas online como a HackerRank e LeetCode. E essas plataformas t\u00eam desafios de programa\u00e7\u00e3o para todos os n\u00edveis. Dessa forma \u00e9 poss\u00edvel treinar l\u00f3gica como tamb\u00e9m estrutura de dados como ferramentas para resolu\u00e7\u00e3o do\u00a0mesmo.</p>\n<h3>Problema</h3>\n<p>Dito isso, durante um exerc\u00edcio achei que seria relevante compartilhar. Num primeiro momento ele parece bem simples. O enunciado \u00e9 o seguinte.</p>\n<blockquote><em>Dado um vetor de inteiros, nums, contendo n+1 inteiros onde cada inteiro est\u00e1 no intervalo [1,n]\u00a0. Existe apenas um n\u00famero repetido em nums, retorne esse n\u00famero\u00a0repetido</em></blockquote>\n<p>As restri\u00e7\u00f5es s\u00e3o</p>\n<ul>\n<li>1\u2264 n\u226410\u2075</li>\n<li>nums.length == n +\u00a01</li>\n<li>1 &lt;= nums[i] &lt;=\u00a0n</li>\n<li>Todos os inteiros em nums aparecem apenas uma vez, exceto precisamente um inteiro que aparece duas ou mais\u00a0vezes.</li>\n</ul>\n<p>A obrigatoriedade de conter um inteiro repetido vem do<strong> Pigeonhole principle</strong>. \u00c9 um princ\u00edpio bem conhecido na matem\u00e1tica, voc\u00eas podem consultar isso facilmente na internet. \u00c9 recomend\u00e1vel olhar a prova, \u00e9 bem interessante como faz alus\u00e3o \u00e0 v\u00e1rios problemas reais.</p>\n<p>Bem, o que dificulta o problema \u00e9 restri\u00e7\u00e3o na solu\u00e7\u00e3o que\u00a0\u00e9:</p>\n<blockquote><em>Voc\u00ea deve resolver o problema sem modificar o vetor nums e usa apenas espa\u00e7o extra constante.</em></blockquote>\n<p>Como pode ser visto essa restri\u00e7\u00e3o torna o problema dif\u00edcil, tendo em vista que n\u00e3o \u00e9 poss\u00edvel usar nenhum estrutura de dados e tamb\u00e9m n\u00e3o \u00e9 poss\u00edvel modificar o vetor\u00a0nums.</p>\n<h3>Solu\u00e7\u00e3o</h3>\n<p>Esse \u00e9 um problema cl\u00e1ssico, com duas solu\u00e7\u00f5es poss\u00edveis. A primeira que usarei, estarei ignorando a restri\u00e7\u00e3o de modifica\u00e7\u00e3o do problema. Essa forma \u00e9 apenas um come\u00e7o para gente pensar em como resolver esse problema.</p>\n<p>Bem, para come\u00e7ar usarei uma abordagem bem simples, mas que resolveria esse problema se n\u00e3o houvesse restri\u00e7\u00e3o na\u00a0solu\u00e7\u00e3o.</p>\n<p>A ideia \u00e9 a seguinte, a primeiro momento nosso vetor tem valores espalhados e n\u00e3o segue uma ordem espec\u00edfica. Mas e se fizessemos a ordena\u00e7\u00e3o desse vetor? Os valores duplicados estariam perto um do\u00a0outro.</p>\n<p>Temos que:</p>\n<ol>\n<li>Ordenar o vetor\u00a0nums;</li>\n<li>Executar um loop para examinar os elementos e se o elemento subsequente for igual ao antecessor temos o valor duplicado;</li>\n<li>Retorna o primeiro n\u00famero que \u00e9 igual ao seu antecessor.</li>\n</ol>\n<p>O c\u00f3digo em python fica da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        nums.sort()<br>        for i in range(1, len(nums)):<br>            if nums[i] == nums[i-1]:<br>                return nums[i]</pre>\n<p>Essa solu\u00e7\u00e3o j\u00e1 seria suficiente, pois se analisarmos a Complexidade ter\u00edamos o seguinte:</p>\n<ul><li>\n<strong>Complexidade de tempo\u00a0:</strong> O(n log\u00a0n)</li></ul>\n<p>Ordena\u00e7\u00e3o leva O(n log n). E seguindo fazer uma loop linear para avaliar os elementos do vetor assim resultando, O(n log n) + O(n) = O(n log\u00a0n)</p>\n<ul><li>\n<strong>Complexidade no espa\u00e7o</strong>: <em>O(logn)</em> or\u00a0<em>O(n)</em>\n</li></ul>\n<p>A complexidade do espa\u00e7o do algoritmo de ordena\u00e7\u00e3o depende da implementa\u00e7\u00e3o de cada linguagem de programa\u00e7\u00e3o:</p>\n<ul>\n<li>Java, Arrays.sort() \u00e9 implementado usando uma variante do algoritmo Quick Sort, que tem uma complexidade de espa\u00e7o de O(log\u00a0n)</li>\n<li>Em C++, a fun\u00e7\u00e3o sort() fornecida pelo STL usa um h\u00edbrido de Quick Sort, Heap Sort e Insertion Sort, com uma complexidade de espa\u00e7o no pior caso de O(log\u00a0n)</li>\n<li>Em Python, a fun\u00e7\u00e3o sort() \u00e9 implementada usando o algoritmo Timsort, que tem uma complexidade de espa\u00e7o de pior caso de\u00a0O(n)</li>\n</ul>\n<p>A restri\u00e7\u00e3o no espa\u00e7o tamb\u00e9m se tonar um problema, j\u00e1 que poder\u00edamos usar um HashMap para contar valores os valores e armazen\u00e1-los. Assim temos que pensar um pouco mais para assim conseguir pensar numa solu\u00e7\u00e3o que siga essa restri\u00e7\u00e3o.</p>\n<h3>Detec\u00e7\u00e3o C\u00edclica</h3>\n<p>Podemos usar um algoritmo de detec\u00e7\u00e3o c\u00edclica. A ide\u00e1 \u00e9 pensar que esse vetor possar ser tratado como uma lista encadeada e como temos um valor repetido esse valor far\u00e1 a lista conter um ciclo. Pode ser observado na figura abaixo a\u00a0ideia.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GlBRiPadpVQv9xqoLMfU1A.png\"></figure><p>Como pode ser visto o valor duplicado em nosso vetor se tornar a entrada em nosso ciclo. A ideia \u00e9 reduzir esse problema a <a href=\"https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem\">Cycle Detection</a> ou <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/\">Linked List Cycle\u00a0II</a>.</p>\n<p>Podemos aumentar o tamanho do vetor nums para ilustrar melhor nosso problema.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oxz5lWqerwMRdDqIcSi36Q.png\"></figure><h3>Floyd\u2019s Hare and\u00a0Tortoise</h3>\n<p>\u00c9 um algoritmo de ponteiro que usa apenas dois ponteiros, que se movem pela sequ\u00eancia em velocidades diferentes. Tamb\u00e9m \u00e9 chamado de \u201calgoritmo da tartaruga e da lebre\u201d, aludindo \u00e0 f\u00e1bula de Esopo, A tartaruga e a\u00a0lebre.</p>\n<p>Para entender de maneira clara dividiremos o procedimento em duas partes. Assim, trazendo ela para o nosso problema tem o seguinte.</p>\n<p><strong>Primeira Fase:</strong></p>\n<p>hare = nums[nums[hare]] \u00e9 duas vezes mais r\u00e1pido que tortoise = nums[tortoise]. Como a lebre anda r\u00e1pido, seria a primeira a entrar no ciclo e correr ao redor do ciclo. Em algum momento, a tartaruga tamb\u00e9m entra no ciclo e, como est\u00e1 se movendo mais devagar, a lebre alcan\u00e7a a tartaruga em algum ponto de interse\u00e7\u00e3o. Agora a fase 1 acabou e a tartaruga perdeu.</p>\n<blockquote><em>Observe que o ponto de interse\u00e7\u00e3o n\u00e3o \u00e9 a entrada do ciclo no caso\u00a0geral.</em></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OYJE40t-qH22Of2_.png\"></figure><p>\u00c9 poss\u00edvel calcular a interse\u00e7\u00e3o, basta notar que a lebre(hare) percorreu o dobro da tartaruga(tortoise), ou seja, 2d(tortoise) =\u00a0d(hare):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/211/0*tWsxGp0z0MuS8gM1\"></figure><p>Onde n \u00e9 um n\u00famero inteiro. \u00c9 importante notar que esse passo \u00e9 crucial e prova que algoritmo de Floyd funciona. Visto que estamos calculando a dist\u00e2ncia do primeiro elemento da lista at\u00e9 o ponto da interse\u00e7\u00e3o, essa conta se tonar algo indispens\u00e1vel para implementar a pr\u00f3xima fase do algoritmo.</p>\n<p><strong>Segunda Fase:</strong></p>\n<p>Nessa fase daremos a tartaruga uma segunda chance, ou seja, diminuiremos a velocidade da lebre, de modo que agora ela se mova na velocidade da tartaruga: tortoise = nums[tortoise]\u00a0,hare = nums[hare]. A tartaruga est\u00e1 de volta \u00e0 posi\u00e7\u00e3o inicial e a lebre parte do ponto de interse\u00e7\u00e3o.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*p2uHTOH37bK6ma7QKYdw9w.png\"></figure><p>Mostraremos que desta vez eles se encontram na entrada do ciclo ap\u00f3s F\u00a0passos.</p>\n<ul>\n<li>A tartaruga come\u00e7ou em zero, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s o F passos \u00e9\u00a0F.</li>\n<li>A lebre come\u00e7ou no ponto de interse\u00e7\u00e3o F + a = nC, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s F passos \u00e9 nC+F, o mesmo ponto que\u00a0F.</li>\n<li>Assim, a tartaruga e a lebre (desacelerada) se encontrar\u00e3o na entrada do\u00a0ciclo.</li>\n</ul>\n<p>A imagem abaixo mostra o que acontece durante todas as\u00a0fases.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/1*09n9E-RUgjCd6uIRzue7Gg.gif\"></figure><p>O c\u00f3digo em python \u00e9 escrito da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        # Ache o ponto de interse\u00e7\u00e3o dos ponteiros<br>        tortoise = hare = nums[0]<br>        while True:<br>            tortoise = nums[tortoise]<br>            hare = nums[nums[hare]]<br>            if tortoise == hare:<br>                break<br><br>        # Ache o a entrada dentro do ciclo.<br>        tortoise = nums[0]<br>        while tortoise != hare:<br>            tortoise = nums[tortoise]<br>            hare = nums[hare]<br><br>        return hare</pre>\n<ul>\n<li>\n<strong>Complexidade de tempo:</strong>\u00a0O(n)</li>\n<li>\n<strong>Complexidade no espa\u00e7o</strong>:\u00a0<em>O(1)</em>\n</li>\n</ul>\n<p>Aplicando esse m\u00e9todo temos uma solu\u00e7\u00e3o bem elegante e otimizada do nosso problema. Essa categoria de problema \u00e9 aquela que se torna trivial quando se resolve, mas num primeiro momento n\u00e3o \u00e9 intuitivo reduzi-lo em um problema de listas encadeada c\u00edclicas.</p>\n<p>Se houver d\u00favida ainda, \u00e9 poss\u00edvel printar no console os valores dos ponteiros tortoise e hare, para melhorar a visualiza\u00e7\u00e3o.</p>\n<h3>Referencias</h3>\n<ul>\n<li>Explica\u00e7\u00e3o em video pode ser vista\u00a0<a href=\"https://www.youtube.com/watch?v=wjYnzkAhcNk\">aqui</a>.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cycle_detection\">Wikipedia</a></li>\n<li>Problema pode se encontrado <a href=\"https://leetcode.com/problems/find-the-duplicate-number/\">aqui</a>.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=69ead8889a2f\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["leetcode","algorithms"]}]}