{"status":"ok","feed":{"url":"https://medium.com/feed/@rgribeiro","title":"Stories by Rafael Ribeiro on Medium","link":"https://medium.com/@rgribeiro?source=rss-303f8669abf9------2","author":"","description":"Stories by Rafael Ribeiro on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*kENQbV6PMDnIwa823jhf-Q.png"},"items":[{"title":"O Que \u00e9 TCP/IP?","pubDate":"2023-01-23 12:26:43","link":"https://medium.com/@rgribeiro/o-que-%C3%A9-tcp-ip-bbd36bea7c0b?source=rss-303f8669abf9------2","guid":"https://medium.com/p/bbd36bea7c0b","author":"Rafael Ribeiro","thumbnail":"https://cdn-images-1.medium.com/max/1024/0*KqEHVB_VJX0_4c_e","description":"\n<h4>Um breve resumo sobre o que \u00e9 o protocolo TCP/IP.</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KqEHVB_VJX0_4c_e\"><figcaption>Photo by <a href=\"https://unsplash.com/@jordanharrison?utm_source=medium&amp;utm_medium=referral\">Jordan Harrison</a> on\u00a0<a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>Durante uma busca pela internet por algum de desafio, acabei me deparando com a seguinte proposta.</p>\n<h4>Criar um sistema de comunica\u00e7\u00e3o com o protocolo TCP.</h4>\n<p>Onde n\u00e3o \u00e9 permitido e usar outro m\u00e9todo de comunica\u00e7\u00e3o como HTTP ou WebSocket. E usar a linguagem de programa\u00e7\u00e3o em Go para criar um servidor e cliente onde a comunica\u00e7\u00e3o ser\u00e1 dado pelo protocolo TCP.</p>\n<p><strong>Requisitos</strong></p>\n<ul>\n<li>Criar um servidor TCP que escuta numa porta especificada por uma vari\u00e1vel de ambiente\u00a0PORT</li>\n<li>Criar um cliente TCP que se conecta a um servidor.</li>\n<li>Quando um cliente se conecta ao servidor, um id \u00fanico \u00e9 gerado e enviado de volta ao\u00a0cliente.</li>\n<li>O cliente pode enviar mensagens com tr\u00eas\u00a0dados:</li>\n<li>id\u200a\u2014\u200ao id do cliente (obrigat\u00f3rio)</li>\n<li>action\u200a\u2014\u200auma a\u00e7\u00e3o esperada pelo servidor (obrigat\u00f3rio)</li>\n<li>body\u200a\u2014\u200aqualquer dado (json, texto puro, tanto faz) que um cliente deseja envivar para o servidor (opcional)</li>\n<li>Quando o cliente envia uma mensagem com action LIST o servidor deve retornar uma lista de todos os ids de clientes conectados.</li>\n<li>Quando o cliente envia uma mensagem com action RELAY o servidor deve enviar a mensagem do campo body para todos os clientes conectados.</li>\n</ul>\n<p><strong>Assim fiquei me perguntando o que a final seria esse protocolo?</strong> Dessa forma, achei interessante fazer escrever um resumo sobre e tentar explicar como funcion\u00e1rio um c\u00f3digo dessa forma para ser poss\u00edvel.</p>\n<p>O protocolo TCP/IP \u00e9 um conjunto de regras e padr\u00f5es que governam a comunica\u00e7\u00e3o de dados na Internet e em redes privadas baseadas em IP. Ele \u00e9 composto por dois protocolos principais: o <strong>TCP (Transmission Control Protocol) e o IP (Internet Protocol).</strong></p>\n<p>O TCP \u00e9 respons\u00e1vel por garantir que as informa\u00e7\u00f5es sejam transmitidas de forma confi\u00e1vel e correta, enquanto o IP \u00e9 respons\u00e1vel por garantir que as informa\u00e7\u00f5es cheguem ao destino correto. Juntos, esses protocolos permitem que dispositivos em diferentes redes se comuniquem entre\u00a0si.</p>\n<p><strong>TCP </strong>\u00e9 um protocolo orientado a conex\u00e3o, ou seja, antes de iniciar a comunica\u00e7\u00e3o entre dispositivos, \u00e9 estabelecida uma conex\u00e3o l\u00f3gica sendo garantida a confiabilidade na transmiss\u00e3o, ele tamb\u00e9m \u00e9 respons\u00e1vel por controlar o fluxo de dados, retransmitir pacotes perdidos e garantir a ordena\u00e7\u00e3o correta dos\u00a0pacotes.</p>\n<p><strong>J\u00e1 o IP \u00e9 um protocolo orientado a pacote, ele \u00e9 respons\u00e1vel por identificar e endere\u00e7ar os dispositivos na rede, al\u00e9m de encaminhar os pacotes de dados ao destino\u00a0correto.</strong></p>\n<p>Juntos, esses dois protocolos permitem que os dispositivos em uma rede se comuniquem entre si e que os dados viajem de forma confi\u00e1vel e precisa atrav\u00e9s da Internet e outras redes baseadas em\u00a0IP.</p>\n<h4>Como funciona?</h4>\n<p>As conex\u00f5es TCP funcionam atrav\u00e9s de um processo chamado de \u201chandshake\u201d de tr\u00eas etapas. O handshake de tr\u00eas etapas \u00e9 um processo que estabelece uma conex\u00e3o entre dois dispositivos em uma rede antes que qualquer dado seja trocado. O processo consiste em tr\u00eas\u00a0etapas:</p>\n<ol>\n<li>O dispositivo iniciador, conhecido como cliente, envia um pacote com a bandeira SYN (sincronizar) para o dispositivo de destino, conhecido como servidor. Este pacote \u00e9 chamado de pacote SYN e serve como uma solicita\u00e7\u00e3o para iniciar uma\u00a0conex\u00e3o.</li>\n<li>O servidor recebe o pacote SYN e responde com um pacote com as bandeiras SYN e ACK (confirmar) configuradas. Este pacote \u00e9 chamado de pacote SYN-ACK e serve como uma confirma\u00e7\u00e3o da solicita\u00e7\u00e3o do cliente para iniciar uma\u00a0conex\u00e3o.</li>\n<li>O cliente recebe o pacote SYN-ACK e envia um pacote com apenas a bandeira ACK configurada. Este pacote \u00e9 chamado de pacote ACK e serve como uma confirma\u00e7\u00e3o final do estabelecimento da\u00a0conex\u00e3o.</li>\n</ol>\n<p>Neste ponto, a conex\u00e3o \u00e9 estabelecida e os dados podem ser trocados entre o cliente e o servidor. Uma vez que a transfer\u00eancia de dados est\u00e1 completa, qualquer lado pode iniciar a finaliza\u00e7\u00e3o da conex\u00e3o, o que \u00e9 feito atrav\u00e9s de um processo semelhante de enviar pacotes com a bandeira FIN (finalizar). Este processo \u00e9 chamado de \u201chandshake\u201d de quatro etapas sendo usado para fechar a\u00a0conex\u00e3o.</p>\n<h4>C\u00f3digo em\u00a0GO</h4>\n<p>Para fazer esse teste de conceito eu crie um simples c\u00f3digo em GO que pode se encontrado <a href=\"https://github.com/rafaelmgr12/simple-tcp-server\">aqui</a>.</p>\n<p>Neste projeto simples, foi desenvolvido um servidor que utiliza o protocolo TCP e fica escutando quando um cliente se conecta. Dessa forma, \u00e9 poss\u00edvel se comunicar com o servidor, enviando e/ou recebendo dados.</p>\n<p>Al\u00e9m disso, devido \u00e0 facilidade de lidar com concorr\u00eancia na linguagem Go, este c\u00f3digo consegue gerenciar eficazmente v\u00e1rios clientes conectados simultaneamente ao nosso servidor.</p>\n<h3><strong>De volta para o\u00a0desafio</strong></h3>\n<p>Com esse tutorial feito podemos modificar para ser poss\u00edvel implementar os requisitos propostos pelo\u00a0desafio.</p>\n<p>Eu dividi o trabalho em algumas partes,\u00a0segue:</p>\n<ol>\n<li>Criar um servidor TCP que escuta na porta especificada por uma vari\u00e1vel de ambiente PORT: Utilize a biblioteca net do Go para criar um servidor TCP que escuta na porta especificada.</li>\n<li>Criar um cliente TCP que se conecta a um servidor: Utilize a biblioteca net do Go para criar um cliente TCP que se conecta ao servidor.</li>\n<li>Gerar um id \u00fanico para cada cliente que se conecta ao servidor: crie um m\u00e9todo para gerar um id \u00fanico para cada cliente que se conecta ao servidor. Envie este id de volta ao cliente quando ele se conectar.</li>\n<li>Implementar a\u00e7\u00f5es esperadas pelo servidor: Para as a\u00e7\u00f5es esperadas pelo servidor, como \u201cLIST\u201d e \u201cRELAY\u201d, implemente as l\u00f3gicas necess\u00e1rias para que o servidor possa processar essas\u00a0a\u00e7\u00f5es.</li>\n<li>Enviar e receber dados entre cliente e servidor: utilize a biblioteca io do Go para enviar e receber dados entre o cliente e o servidor.</li>\n</ol>\n<p>O primeiro passo \u00e9 simples: algumas modifica\u00e7\u00f5es simples no tutorial s\u00e3o necess\u00e1rias, especificamente definir uma vari\u00e1vel de ambiente para a porta do servidor e fazer o mesmo para o cliente. Assim, o primeiro requisito est\u00e1\u00a0pronto.</p>\n<p>Agora, geraremos um ID \u00fanico. Escolhi gerar a partir de um UUID e para isso usei a biblioteca do Google chamada UUID (o link das bibliotecas usadas est\u00e1 no meu reposit\u00f3rio). Em seguida, basta enviar o ID para o cliente quando ele se conectar \u00e0 aplica\u00e7\u00e3o.</p>\n<p>A configura\u00e7\u00e3o de envio e recebimento foi feita com as bibliotecas net e io, bibliotecas padr\u00e3o do Go. Essa parte foi um pouco complicada; o c\u00f3digo precisa ser melhorado para ser mais leg\u00edvel e\u00a0limpo.</p>\n<p>Por \u00faltimo, implementamos os m\u00e9todos \u201cLIST\u201d e \u201cRELAY\u201d. Para ambos, foi necess\u00e1rio usar a estrutura de dados de hashmap para mapear o ID e o endere\u00e7o da conex\u00e3o do cliente. Ent\u00e3o, basta configurar alguns switch case para executar os\u00a0m\u00e9todos.</p>\n<p>Para ter algum m\u00e9todo de autentica\u00e7\u00e3o, tamb\u00e9m implementei um m\u00e9todo simples, onde o cliente precisa enviar o ID gerado pelo servidor de volta para ser poss\u00edvel acessar os m\u00e9todos requisitados.</p>\n<p><strong>Conclus\u00e3o</strong></p>\n<p>\u00c9 a primeira vez que fiz uma implementa\u00e7\u00e3o de um servidor/cliente usando o protocolo TCP. Portanto, tive que pesquisar e estudar sobre o que \u00e9 e definir alguns pontos para come\u00e7ar. Como desenvolvi isso em apenas 3 dias e sem nunca ter visto esse tipo de protocolo, ainda n\u00e3o consegui chegar no padr\u00e3o de qualidade de c\u00f3digo que eu desejo. H\u00e1 alguns problemas de design, mas a refatora\u00e7\u00e3o pode ser feita mais tarde. Esse desafio foi bem dif\u00edcil, j\u00e1 que me tirou da minha zona de conforto, mas acho que foi legal aprender mais sobre redes e protocolos.</p>\n<p>O reposit\u00f3rio do projeto est\u00e1\u00a0aqui:</p>\n<p><a href=\"https://github.com/rafaelmgr12/syscom-tcp\">GitHub - rafaelmgr12/syscom-tcp</a></p>\n<h3>Refer\u00eancias:</h3>\n<p><a href=\"https://www.golinuxcloud.com/golang-tcp-server-client/\">Golang TCP Server and Client Example [Tutorial] | GoLinuxCloud</a></p>\n<p><a href=\"http://www.inanzzz.com/index.php/post/j3n1/creating-a-concurrent-tcp-client-and-server-example-with-golang\">Creating a concurrent TCP client and server example with\u00a0Golang</a></p>\n<p><a href=\"https://www.linode.com/docs/guides/developing-udp-and-tcp-clients-and-servers-in-go/\">Create a TCP and UDP Client and Server using\u00a0Go</a></p>\n<p><a href=\"https://systembash.com/a-simple-go-tcp-server-and-tcp-client/\">A Simple Go TCP Server and TCP\u00a0Client</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bbd36bea7c0b\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h4>Um breve resumo sobre o que \u00e9 o protocolo TCP/IP.</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KqEHVB_VJX0_4c_e\"><figcaption>Photo by <a href=\"https://unsplash.com/@jordanharrison?utm_source=medium&amp;utm_medium=referral\">Jordan Harrison</a> on\u00a0<a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>Durante uma busca pela internet por algum de desafio, acabei me deparando com a seguinte proposta.</p>\n<h4>Criar um sistema de comunica\u00e7\u00e3o com o protocolo TCP.</h4>\n<p>Onde n\u00e3o \u00e9 permitido e usar outro m\u00e9todo de comunica\u00e7\u00e3o como HTTP ou WebSocket. E usar a linguagem de programa\u00e7\u00e3o em Go para criar um servidor e cliente onde a comunica\u00e7\u00e3o ser\u00e1 dado pelo protocolo TCP.</p>\n<p><strong>Requisitos</strong></p>\n<ul>\n<li>Criar um servidor TCP que escuta numa porta especificada por uma vari\u00e1vel de ambiente\u00a0PORT</li>\n<li>Criar um cliente TCP que se conecta a um servidor.</li>\n<li>Quando um cliente se conecta ao servidor, um id \u00fanico \u00e9 gerado e enviado de volta ao\u00a0cliente.</li>\n<li>O cliente pode enviar mensagens com tr\u00eas\u00a0dados:</li>\n<li>id\u200a\u2014\u200ao id do cliente (obrigat\u00f3rio)</li>\n<li>action\u200a\u2014\u200auma a\u00e7\u00e3o esperada pelo servidor (obrigat\u00f3rio)</li>\n<li>body\u200a\u2014\u200aqualquer dado (json, texto puro, tanto faz) que um cliente deseja envivar para o servidor (opcional)</li>\n<li>Quando o cliente envia uma mensagem com action LIST o servidor deve retornar uma lista de todos os ids de clientes conectados.</li>\n<li>Quando o cliente envia uma mensagem com action RELAY o servidor deve enviar a mensagem do campo body para todos os clientes conectados.</li>\n</ul>\n<p><strong>Assim fiquei me perguntando o que a final seria esse protocolo?</strong> Dessa forma, achei interessante fazer escrever um resumo sobre e tentar explicar como funcion\u00e1rio um c\u00f3digo dessa forma para ser poss\u00edvel.</p>\n<p>O protocolo TCP/IP \u00e9 um conjunto de regras e padr\u00f5es que governam a comunica\u00e7\u00e3o de dados na Internet e em redes privadas baseadas em IP. Ele \u00e9 composto por dois protocolos principais: o <strong>TCP (Transmission Control Protocol) e o IP (Internet Protocol).</strong></p>\n<p>O TCP \u00e9 respons\u00e1vel por garantir que as informa\u00e7\u00f5es sejam transmitidas de forma confi\u00e1vel e correta, enquanto o IP \u00e9 respons\u00e1vel por garantir que as informa\u00e7\u00f5es cheguem ao destino correto. Juntos, esses protocolos permitem que dispositivos em diferentes redes se comuniquem entre\u00a0si.</p>\n<p><strong>TCP </strong>\u00e9 um protocolo orientado a conex\u00e3o, ou seja, antes de iniciar a comunica\u00e7\u00e3o entre dispositivos, \u00e9 estabelecida uma conex\u00e3o l\u00f3gica sendo garantida a confiabilidade na transmiss\u00e3o, ele tamb\u00e9m \u00e9 respons\u00e1vel por controlar o fluxo de dados, retransmitir pacotes perdidos e garantir a ordena\u00e7\u00e3o correta dos\u00a0pacotes.</p>\n<p><strong>J\u00e1 o IP \u00e9 um protocolo orientado a pacote, ele \u00e9 respons\u00e1vel por identificar e endere\u00e7ar os dispositivos na rede, al\u00e9m de encaminhar os pacotes de dados ao destino\u00a0correto.</strong></p>\n<p>Juntos, esses dois protocolos permitem que os dispositivos em uma rede se comuniquem entre si e que os dados viajem de forma confi\u00e1vel e precisa atrav\u00e9s da Internet e outras redes baseadas em\u00a0IP.</p>\n<h4>Como funciona?</h4>\n<p>As conex\u00f5es TCP funcionam atrav\u00e9s de um processo chamado de \u201chandshake\u201d de tr\u00eas etapas. O handshake de tr\u00eas etapas \u00e9 um processo que estabelece uma conex\u00e3o entre dois dispositivos em uma rede antes que qualquer dado seja trocado. O processo consiste em tr\u00eas\u00a0etapas:</p>\n<ol>\n<li>O dispositivo iniciador, conhecido como cliente, envia um pacote com a bandeira SYN (sincronizar) para o dispositivo de destino, conhecido como servidor. Este pacote \u00e9 chamado de pacote SYN e serve como uma solicita\u00e7\u00e3o para iniciar uma\u00a0conex\u00e3o.</li>\n<li>O servidor recebe o pacote SYN e responde com um pacote com as bandeiras SYN e ACK (confirmar) configuradas. Este pacote \u00e9 chamado de pacote SYN-ACK e serve como uma confirma\u00e7\u00e3o da solicita\u00e7\u00e3o do cliente para iniciar uma\u00a0conex\u00e3o.</li>\n<li>O cliente recebe o pacote SYN-ACK e envia um pacote com apenas a bandeira ACK configurada. Este pacote \u00e9 chamado de pacote ACK e serve como uma confirma\u00e7\u00e3o final do estabelecimento da\u00a0conex\u00e3o.</li>\n</ol>\n<p>Neste ponto, a conex\u00e3o \u00e9 estabelecida e os dados podem ser trocados entre o cliente e o servidor. Uma vez que a transfer\u00eancia de dados est\u00e1 completa, qualquer lado pode iniciar a finaliza\u00e7\u00e3o da conex\u00e3o, o que \u00e9 feito atrav\u00e9s de um processo semelhante de enviar pacotes com a bandeira FIN (finalizar). Este processo \u00e9 chamado de \u201chandshake\u201d de quatro etapas sendo usado para fechar a\u00a0conex\u00e3o.</p>\n<h4>C\u00f3digo em\u00a0GO</h4>\n<p>Para fazer esse teste de conceito eu crie um simples c\u00f3digo em GO que pode se encontrado <a href=\"https://github.com/rafaelmgr12/simple-tcp-server\">aqui</a>.</p>\n<p>Neste projeto simples, foi desenvolvido um servidor que utiliza o protocolo TCP e fica escutando quando um cliente se conecta. Dessa forma, \u00e9 poss\u00edvel se comunicar com o servidor, enviando e/ou recebendo dados.</p>\n<p>Al\u00e9m disso, devido \u00e0 facilidade de lidar com concorr\u00eancia na linguagem Go, este c\u00f3digo consegue gerenciar eficazmente v\u00e1rios clientes conectados simultaneamente ao nosso servidor.</p>\n<h3><strong>De volta para o\u00a0desafio</strong></h3>\n<p>Com esse tutorial feito podemos modificar para ser poss\u00edvel implementar os requisitos propostos pelo\u00a0desafio.</p>\n<p>Eu dividi o trabalho em algumas partes,\u00a0segue:</p>\n<ol>\n<li>Criar um servidor TCP que escuta na porta especificada por uma vari\u00e1vel de ambiente PORT: Utilize a biblioteca net do Go para criar um servidor TCP que escuta na porta especificada.</li>\n<li>Criar um cliente TCP que se conecta a um servidor: Utilize a biblioteca net do Go para criar um cliente TCP que se conecta ao servidor.</li>\n<li>Gerar um id \u00fanico para cada cliente que se conecta ao servidor: crie um m\u00e9todo para gerar um id \u00fanico para cada cliente que se conecta ao servidor. Envie este id de volta ao cliente quando ele se conectar.</li>\n<li>Implementar a\u00e7\u00f5es esperadas pelo servidor: Para as a\u00e7\u00f5es esperadas pelo servidor, como \u201cLIST\u201d e \u201cRELAY\u201d, implemente as l\u00f3gicas necess\u00e1rias para que o servidor possa processar essas\u00a0a\u00e7\u00f5es.</li>\n<li>Enviar e receber dados entre cliente e servidor: utilize a biblioteca io do Go para enviar e receber dados entre o cliente e o servidor.</li>\n</ol>\n<p>O primeiro passo \u00e9 simples: algumas modifica\u00e7\u00f5es simples no tutorial s\u00e3o necess\u00e1rias, especificamente definir uma vari\u00e1vel de ambiente para a porta do servidor e fazer o mesmo para o cliente. Assim, o primeiro requisito est\u00e1\u00a0pronto.</p>\n<p>Agora, geraremos um ID \u00fanico. Escolhi gerar a partir de um UUID e para isso usei a biblioteca do Google chamada UUID (o link das bibliotecas usadas est\u00e1 no meu reposit\u00f3rio). Em seguida, basta enviar o ID para o cliente quando ele se conectar \u00e0 aplica\u00e7\u00e3o.</p>\n<p>A configura\u00e7\u00e3o de envio e recebimento foi feita com as bibliotecas net e io, bibliotecas padr\u00e3o do Go. Essa parte foi um pouco complicada; o c\u00f3digo precisa ser melhorado para ser mais leg\u00edvel e\u00a0limpo.</p>\n<p>Por \u00faltimo, implementamos os m\u00e9todos \u201cLIST\u201d e \u201cRELAY\u201d. Para ambos, foi necess\u00e1rio usar a estrutura de dados de hashmap para mapear o ID e o endere\u00e7o da conex\u00e3o do cliente. Ent\u00e3o, basta configurar alguns switch case para executar os\u00a0m\u00e9todos.</p>\n<p>Para ter algum m\u00e9todo de autentica\u00e7\u00e3o, tamb\u00e9m implementei um m\u00e9todo simples, onde o cliente precisa enviar o ID gerado pelo servidor de volta para ser poss\u00edvel acessar os m\u00e9todos requisitados.</p>\n<p><strong>Conclus\u00e3o</strong></p>\n<p>\u00c9 a primeira vez que fiz uma implementa\u00e7\u00e3o de um servidor/cliente usando o protocolo TCP. Portanto, tive que pesquisar e estudar sobre o que \u00e9 e definir alguns pontos para come\u00e7ar. Como desenvolvi isso em apenas 3 dias e sem nunca ter visto esse tipo de protocolo, ainda n\u00e3o consegui chegar no padr\u00e3o de qualidade de c\u00f3digo que eu desejo. H\u00e1 alguns problemas de design, mas a refatora\u00e7\u00e3o pode ser feita mais tarde. Esse desafio foi bem dif\u00edcil, j\u00e1 que me tirou da minha zona de conforto, mas acho que foi legal aprender mais sobre redes e protocolos.</p>\n<p>O reposit\u00f3rio do projeto est\u00e1\u00a0aqui:</p>\n<p><a href=\"https://github.com/rafaelmgr12/syscom-tcp\">GitHub - rafaelmgr12/syscom-tcp</a></p>\n<h3>Refer\u00eancias:</h3>\n<p><a href=\"https://www.golinuxcloud.com/golang-tcp-server-client/\">Golang TCP Server and Client Example [Tutorial] | GoLinuxCloud</a></p>\n<p><a href=\"http://www.inanzzz.com/index.php/post/j3n1/creating-a-concurrent-tcp-client-and-server-example-with-golang\">Creating a concurrent TCP client and server example with\u00a0Golang</a></p>\n<p><a href=\"https://www.linode.com/docs/guides/developing-udp-and-tcp-clients-and-servers-in-go/\">Create a TCP and UDP Client and Server using\u00a0Go</a></p>\n<p><a href=\"https://systembash.com/a-simple-go-tcp-server-and-tcp-client/\">A Simple Go TCP Server and TCP\u00a0Client</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bbd36bea7c0b\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["go","tcp"]},{"title":"Como encontrar elementos duplicados em uma Lista?","pubDate":"2022-07-12 11:12:44","link":"https://medium.com/@rgribeiro/como-achar-elementos-duplicados-em-uma-lista-69ead8889a2f?source=rss-303f8669abf9------2","guid":"https://medium.com/p/69ead8889a2f","author":"Rafael Ribeiro","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*GlBRiPadpVQv9xqoLMfU1A.png","description":"\n<p>L\u00f3gica \u00e9 requisito para todo programador, e para continuar me aperfei\u00e7oando, uso algumas plataformas online como a HackerRank e LeetCode. E essas plataformas t\u00eam desafios de programa\u00e7\u00e3o para todos os n\u00edveis. Dessa forma \u00e9 poss\u00edvel treinar l\u00f3gica como tamb\u00e9m estrutura de dados como ferramentas para resolu\u00e7\u00e3o do\u00a0mesmo.</p>\n<h3>Problema</h3>\n<p>Dito isso, durante um exerc\u00edcio achei que seria relevante compartilhar. Num primeiro momento ele parece bem simples. O enunciado \u00e9 o seguinte.</p>\n<blockquote><em>Dado um vetor de inteiros, nums, contendo n+1 inteiros onde cada inteiro est\u00e1 no intervalo [1,n]\u00a0. Existe apenas um n\u00famero repetido em nums, retorne esse n\u00famero\u00a0repetido</em></blockquote>\n<p>As restri\u00e7\u00f5es s\u00e3o</p>\n<ul>\n<li>1\u2264 n\u226410\u2075</li>\n<li>nums.length == n +\u00a01</li>\n<li>1 &lt;= nums[i] &lt;=\u00a0n</li>\n<li>Todos os inteiros em nums aparecem apenas uma vez, exceto precisamente um inteiro que aparece duas ou mais\u00a0vezes.</li>\n</ul>\n<p>A obrigatoriedade de conter um inteiro repetido vem do<strong> Pigeonhole principle</strong>. \u00c9 um princ\u00edpio bem conhecido na matem\u00e1tica, voc\u00eas podem consultar isso facilmente na internet. \u00c9 recomend\u00e1vel olhar a prova, \u00e9 bem interessante como faz alus\u00e3o \u00e0 v\u00e1rios problemas reais.</p>\n<p>Bem, o que dificulta o problema \u00e9 restri\u00e7\u00e3o na solu\u00e7\u00e3o que\u00a0\u00e9:</p>\n<blockquote><em>Voc\u00ea deve resolver o problema sem modificar o vetor nums e usa apenas espa\u00e7o extra constante.</em></blockquote>\n<p>Como pode ser visto essa restri\u00e7\u00e3o torna o problema dif\u00edcil, tendo em vista que n\u00e3o \u00e9 poss\u00edvel usar nenhum estrutura de dados e tamb\u00e9m n\u00e3o \u00e9 poss\u00edvel modificar o vetor\u00a0nums.</p>\n<h3>Solu\u00e7\u00e3o</h3>\n<p>Esse \u00e9 um problema cl\u00e1ssico, com duas solu\u00e7\u00f5es poss\u00edveis. A primeira que usarei, estarei ignorando a restri\u00e7\u00e3o de modifica\u00e7\u00e3o do problema. Essa forma \u00e9 apenas um come\u00e7o para gente pensar em como resolver esse problema.</p>\n<p>Bem, para come\u00e7ar usarei uma abordagem bem simples, mas que resolveria esse problema se n\u00e3o houvesse restri\u00e7\u00e3o na\u00a0solu\u00e7\u00e3o.</p>\n<p>A ideia \u00e9 a seguinte, a primeiro momento nosso vetor tem valores espalhados e n\u00e3o segue uma ordem espec\u00edfica. Mas e se fizessemos a ordena\u00e7\u00e3o desse vetor? Os valores duplicados estariam perto um do\u00a0outro.</p>\n<p>Temos que:</p>\n<ol>\n<li>Ordenar o vetor\u00a0nums;</li>\n<li>Executar um loop para examinar os elementos e se o elemento subsequente for igual ao antecessor temos o valor duplicado;</li>\n<li>Retorna o primeiro n\u00famero que \u00e9 igual ao seu antecessor.</li>\n</ol>\n<p>O c\u00f3digo em python fica da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        nums.sort()<br>        for i in range(1, len(nums)):<br>            if nums[i] == nums[i-1]:<br>                return nums[i]</pre>\n<p>Essa solu\u00e7\u00e3o j\u00e1 seria suficiente, pois se analisarmos a Complexidade ter\u00edamos o seguinte:</p>\n<ul><li>\n<strong>Complexidade de tempo\u00a0:</strong> O(n log\u00a0n)</li></ul>\n<p>Ordena\u00e7\u00e3o leva O(n log n). E seguindo fazer uma loop linear para avaliar os elementos do vetor assim resultando, O(n log n) + O(n) = O(n log\u00a0n)</p>\n<ul><li>\n<strong>Complexidade no espa\u00e7o</strong>: <em>O(logn)</em> or\u00a0<em>O(n)</em>\n</li></ul>\n<p>A complexidade do espa\u00e7o do algoritmo de ordena\u00e7\u00e3o depende da implementa\u00e7\u00e3o de cada linguagem de programa\u00e7\u00e3o:</p>\n<ul>\n<li>Java, Arrays.sort() \u00e9 implementado usando uma variante do algoritmo Quick Sort, que tem uma complexidade de espa\u00e7o de O(log\u00a0n)</li>\n<li>Em C++, a fun\u00e7\u00e3o sort() fornecida pelo STL usa um h\u00edbrido de Quick Sort, Heap Sort e Insertion Sort, com uma complexidade de espa\u00e7o no pior caso de O(log\u00a0n)</li>\n<li>Em Python, a fun\u00e7\u00e3o sort() \u00e9 implementada usando o algoritmo Timsort, que tem uma complexidade de espa\u00e7o de pior caso de\u00a0O(n)</li>\n</ul>\n<p>A restri\u00e7\u00e3o no espa\u00e7o tamb\u00e9m se tonar um problema, j\u00e1 que poder\u00edamos usar um HashMap para contar valores os valores e armazen\u00e1-los. Assim temos que pensar um pouco mais para assim conseguir pensar numa solu\u00e7\u00e3o que siga essa restri\u00e7\u00e3o.</p>\n<h3>Detec\u00e7\u00e3o C\u00edclica</h3>\n<p>Podemos usar um algoritmo de detec\u00e7\u00e3o c\u00edclica. A ide\u00e1 \u00e9 pensar que esse vetor possar ser tratado como uma lista encadeada e como temos um valor repetido esse valor far\u00e1 a lista conter um ciclo. Pode ser observado na figura abaixo a\u00a0ideia.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GlBRiPadpVQv9xqoLMfU1A.png\"></figure><p>Como pode ser visto o valor duplicado em nosso vetor se tornar a entrada em nosso ciclo. A ideia \u00e9 reduzir esse problema a <a href=\"https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem\">Cycle Detection</a> ou <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/\">Linked List Cycle\u00a0II</a>.</p>\n<p>Podemos aumentar o tamanho do vetor nums para ilustrar melhor nosso problema.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oxz5lWqerwMRdDqIcSi36Q.png\"></figure><h3>Floyd\u2019s Hare and\u00a0Tortoise</h3>\n<p>\u00c9 um algoritmo de ponteiro que usa apenas dois ponteiros, que se movem pela sequ\u00eancia em velocidades diferentes. Tamb\u00e9m \u00e9 chamado de \u201calgoritmo da tartaruga e da lebre\u201d, aludindo \u00e0 f\u00e1bula de Esopo, A tartaruga e a\u00a0lebre.</p>\n<p>Para entender de maneira clara dividiremos o procedimento em duas partes. Assim, trazendo ela para o nosso problema tem o seguinte.</p>\n<p><strong>Primeira Fase:</strong></p>\n<p>hare = nums[nums[hare]] \u00e9 duas vezes mais r\u00e1pido que tortoise = nums[tortoise]. Como a lebre anda r\u00e1pido, seria a primeira a entrar no ciclo e correr ao redor do ciclo. Em algum momento, a tartaruga tamb\u00e9m entra no ciclo e, como est\u00e1 se movendo mais devagar, a lebre alcan\u00e7a a tartaruga em algum ponto de interse\u00e7\u00e3o. Agora a fase 1 acabou e a tartaruga perdeu.</p>\n<blockquote><em>Observe que o ponto de interse\u00e7\u00e3o n\u00e3o \u00e9 a entrada do ciclo no caso\u00a0geral.</em></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OYJE40t-qH22Of2_.png\"></figure><p>\u00c9 poss\u00edvel calcular a interse\u00e7\u00e3o, basta notar que a lebre(hare) percorreu o dobro da tartaruga(tortoise), ou seja, 2d(tortoise) =\u00a0d(hare):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/211/0*tWsxGp0z0MuS8gM1\"></figure><p>Onde n \u00e9 um n\u00famero inteiro. \u00c9 importante notar que esse passo \u00e9 crucial e prova que algoritmo de Floyd funciona. Visto que estamos calculando a dist\u00e2ncia do primeiro elemento da lista at\u00e9 o ponto da interse\u00e7\u00e3o, essa conta se tonar algo indispens\u00e1vel para implementar a pr\u00f3xima fase do algoritmo.</p>\n<p><strong>Segunda Fase:</strong></p>\n<p>Nessa fase daremos a tartaruga uma segunda chance, ou seja, diminuiremos a velocidade da lebre, de modo que agora ela se mova na velocidade da tartaruga: tortoise = nums[tortoise]\u00a0,hare = nums[hare]. A tartaruga est\u00e1 de volta \u00e0 posi\u00e7\u00e3o inicial e a lebre parte do ponto de interse\u00e7\u00e3o.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*p2uHTOH37bK6ma7QKYdw9w.png\"></figure><p>Mostraremos que desta vez eles se encontram na entrada do ciclo ap\u00f3s F\u00a0passos.</p>\n<ul>\n<li>A tartaruga come\u00e7ou em zero, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s o F passos \u00e9\u00a0F.</li>\n<li>A lebre come\u00e7ou no ponto de interse\u00e7\u00e3o F + a = nC, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s F passos \u00e9 nC+F, o mesmo ponto que\u00a0F.</li>\n<li>Assim, a tartaruga e a lebre (desacelerada) se encontrar\u00e3o na entrada do\u00a0ciclo.</li>\n</ul>\n<p>A imagem abaixo mostra o que acontece durante todas as\u00a0fases.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/1*09n9E-RUgjCd6uIRzue7Gg.gif\"></figure><p>O c\u00f3digo em python \u00e9 escrito da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        # Ache o ponto de interse\u00e7\u00e3o dos ponteiros<br>        tortoise = hare = nums[0]<br>        while True:<br>            tortoise = nums[tortoise]<br>            hare = nums[nums[hare]]<br>            if tortoise == hare:<br>                break<br><br>        # Ache o a entrada dentro do ciclo.<br>        tortoise = nums[0]<br>        while tortoise != hare:<br>            tortoise = nums[tortoise]<br>            hare = nums[hare]<br><br>        return hare</pre>\n<ul>\n<li>\n<strong>Complexidade de tempo:</strong>\u00a0O(n)</li>\n<li>\n<strong>Complexidade no espa\u00e7o</strong>:\u00a0<em>O(1)</em>\n</li>\n</ul>\n<p>Aplicando esse m\u00e9todo temos uma solu\u00e7\u00e3o bem elegante e otimizada do nosso problema. Essa categoria de problema \u00e9 aquela que se torna trivial quando se resolve, mas num primeiro momento n\u00e3o \u00e9 intuitivo reduzi-lo em um problema de listas encadeada c\u00edclicas.</p>\n<p>Se houver d\u00favida ainda, \u00e9 poss\u00edvel printar no console os valores dos ponteiros tortoise e hare, para melhorar a visualiza\u00e7\u00e3o.</p>\n<h3>Referencias</h3>\n<ul>\n<li>Explica\u00e7\u00e3o em video pode ser vista\u00a0<a href=\"https://www.youtube.com/watch?v=wjYnzkAhcNk\">aqui</a>.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cycle_detection\">Wikipedia</a></li>\n<li>Problema pode se encontrado <a href=\"https://leetcode.com/problems/find-the-duplicate-number/\">aqui</a>.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=69ead8889a2f\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>L\u00f3gica \u00e9 requisito para todo programador, e para continuar me aperfei\u00e7oando, uso algumas plataformas online como a HackerRank e LeetCode. E essas plataformas t\u00eam desafios de programa\u00e7\u00e3o para todos os n\u00edveis. Dessa forma \u00e9 poss\u00edvel treinar l\u00f3gica como tamb\u00e9m estrutura de dados como ferramentas para resolu\u00e7\u00e3o do\u00a0mesmo.</p>\n<h3>Problema</h3>\n<p>Dito isso, durante um exerc\u00edcio achei que seria relevante compartilhar. Num primeiro momento ele parece bem simples. O enunciado \u00e9 o seguinte.</p>\n<blockquote><em>Dado um vetor de inteiros, nums, contendo n+1 inteiros onde cada inteiro est\u00e1 no intervalo [1,n]\u00a0. Existe apenas um n\u00famero repetido em nums, retorne esse n\u00famero\u00a0repetido</em></blockquote>\n<p>As restri\u00e7\u00f5es s\u00e3o</p>\n<ul>\n<li>1\u2264 n\u226410\u2075</li>\n<li>nums.length == n +\u00a01</li>\n<li>1 &lt;= nums[i] &lt;=\u00a0n</li>\n<li>Todos os inteiros em nums aparecem apenas uma vez, exceto precisamente um inteiro que aparece duas ou mais\u00a0vezes.</li>\n</ul>\n<p>A obrigatoriedade de conter um inteiro repetido vem do<strong> Pigeonhole principle</strong>. \u00c9 um princ\u00edpio bem conhecido na matem\u00e1tica, voc\u00eas podem consultar isso facilmente na internet. \u00c9 recomend\u00e1vel olhar a prova, \u00e9 bem interessante como faz alus\u00e3o \u00e0 v\u00e1rios problemas reais.</p>\n<p>Bem, o que dificulta o problema \u00e9 restri\u00e7\u00e3o na solu\u00e7\u00e3o que\u00a0\u00e9:</p>\n<blockquote><em>Voc\u00ea deve resolver o problema sem modificar o vetor nums e usa apenas espa\u00e7o extra constante.</em></blockquote>\n<p>Como pode ser visto essa restri\u00e7\u00e3o torna o problema dif\u00edcil, tendo em vista que n\u00e3o \u00e9 poss\u00edvel usar nenhum estrutura de dados e tamb\u00e9m n\u00e3o \u00e9 poss\u00edvel modificar o vetor\u00a0nums.</p>\n<h3>Solu\u00e7\u00e3o</h3>\n<p>Esse \u00e9 um problema cl\u00e1ssico, com duas solu\u00e7\u00f5es poss\u00edveis. A primeira que usarei, estarei ignorando a restri\u00e7\u00e3o de modifica\u00e7\u00e3o do problema. Essa forma \u00e9 apenas um come\u00e7o para gente pensar em como resolver esse problema.</p>\n<p>Bem, para come\u00e7ar usarei uma abordagem bem simples, mas que resolveria esse problema se n\u00e3o houvesse restri\u00e7\u00e3o na\u00a0solu\u00e7\u00e3o.</p>\n<p>A ideia \u00e9 a seguinte, a primeiro momento nosso vetor tem valores espalhados e n\u00e3o segue uma ordem espec\u00edfica. Mas e se fizessemos a ordena\u00e7\u00e3o desse vetor? Os valores duplicados estariam perto um do\u00a0outro.</p>\n<p>Temos que:</p>\n<ol>\n<li>Ordenar o vetor\u00a0nums;</li>\n<li>Executar um loop para examinar os elementos e se o elemento subsequente for igual ao antecessor temos o valor duplicado;</li>\n<li>Retorna o primeiro n\u00famero que \u00e9 igual ao seu antecessor.</li>\n</ol>\n<p>O c\u00f3digo em python fica da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        nums.sort()<br>        for i in range(1, len(nums)):<br>            if nums[i] == nums[i-1]:<br>                return nums[i]</pre>\n<p>Essa solu\u00e7\u00e3o j\u00e1 seria suficiente, pois se analisarmos a Complexidade ter\u00edamos o seguinte:</p>\n<ul><li>\n<strong>Complexidade de tempo\u00a0:</strong> O(n log\u00a0n)</li></ul>\n<p>Ordena\u00e7\u00e3o leva O(n log n). E seguindo fazer uma loop linear para avaliar os elementos do vetor assim resultando, O(n log n) + O(n) = O(n log\u00a0n)</p>\n<ul><li>\n<strong>Complexidade no espa\u00e7o</strong>: <em>O(logn)</em> or\u00a0<em>O(n)</em>\n</li></ul>\n<p>A complexidade do espa\u00e7o do algoritmo de ordena\u00e7\u00e3o depende da implementa\u00e7\u00e3o de cada linguagem de programa\u00e7\u00e3o:</p>\n<ul>\n<li>Java, Arrays.sort() \u00e9 implementado usando uma variante do algoritmo Quick Sort, que tem uma complexidade de espa\u00e7o de O(log\u00a0n)</li>\n<li>Em C++, a fun\u00e7\u00e3o sort() fornecida pelo STL usa um h\u00edbrido de Quick Sort, Heap Sort e Insertion Sort, com uma complexidade de espa\u00e7o no pior caso de O(log\u00a0n)</li>\n<li>Em Python, a fun\u00e7\u00e3o sort() \u00e9 implementada usando o algoritmo Timsort, que tem uma complexidade de espa\u00e7o de pior caso de\u00a0O(n)</li>\n</ul>\n<p>A restri\u00e7\u00e3o no espa\u00e7o tamb\u00e9m se tonar um problema, j\u00e1 que poder\u00edamos usar um HashMap para contar valores os valores e armazen\u00e1-los. Assim temos que pensar um pouco mais para assim conseguir pensar numa solu\u00e7\u00e3o que siga essa restri\u00e7\u00e3o.</p>\n<h3>Detec\u00e7\u00e3o C\u00edclica</h3>\n<p>Podemos usar um algoritmo de detec\u00e7\u00e3o c\u00edclica. A ide\u00e1 \u00e9 pensar que esse vetor possar ser tratado como uma lista encadeada e como temos um valor repetido esse valor far\u00e1 a lista conter um ciclo. Pode ser observado na figura abaixo a\u00a0ideia.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GlBRiPadpVQv9xqoLMfU1A.png\"></figure><p>Como pode ser visto o valor duplicado em nosso vetor se tornar a entrada em nosso ciclo. A ideia \u00e9 reduzir esse problema a <a href=\"https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem\">Cycle Detection</a> ou <a href=\"https://leetcode.com/problems/linked-list-cycle-ii/solution/\">Linked List Cycle\u00a0II</a>.</p>\n<p>Podemos aumentar o tamanho do vetor nums para ilustrar melhor nosso problema.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oxz5lWqerwMRdDqIcSi36Q.png\"></figure><h3>Floyd\u2019s Hare and\u00a0Tortoise</h3>\n<p>\u00c9 um algoritmo de ponteiro que usa apenas dois ponteiros, que se movem pela sequ\u00eancia em velocidades diferentes. Tamb\u00e9m \u00e9 chamado de \u201calgoritmo da tartaruga e da lebre\u201d, aludindo \u00e0 f\u00e1bula de Esopo, A tartaruga e a\u00a0lebre.</p>\n<p>Para entender de maneira clara dividiremos o procedimento em duas partes. Assim, trazendo ela para o nosso problema tem o seguinte.</p>\n<p><strong>Primeira Fase:</strong></p>\n<p>hare = nums[nums[hare]] \u00e9 duas vezes mais r\u00e1pido que tortoise = nums[tortoise]. Como a lebre anda r\u00e1pido, seria a primeira a entrar no ciclo e correr ao redor do ciclo. Em algum momento, a tartaruga tamb\u00e9m entra no ciclo e, como est\u00e1 se movendo mais devagar, a lebre alcan\u00e7a a tartaruga em algum ponto de interse\u00e7\u00e3o. Agora a fase 1 acabou e a tartaruga perdeu.</p>\n<blockquote><em>Observe que o ponto de interse\u00e7\u00e3o n\u00e3o \u00e9 a entrada do ciclo no caso\u00a0geral.</em></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OYJE40t-qH22Of2_.png\"></figure><p>\u00c9 poss\u00edvel calcular a interse\u00e7\u00e3o, basta notar que a lebre(hare) percorreu o dobro da tartaruga(tortoise), ou seja, 2d(tortoise) =\u00a0d(hare):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/211/0*tWsxGp0z0MuS8gM1\"></figure><p>Onde n \u00e9 um n\u00famero inteiro. \u00c9 importante notar que esse passo \u00e9 crucial e prova que algoritmo de Floyd funciona. Visto que estamos calculando a dist\u00e2ncia do primeiro elemento da lista at\u00e9 o ponto da interse\u00e7\u00e3o, essa conta se tonar algo indispens\u00e1vel para implementar a pr\u00f3xima fase do algoritmo.</p>\n<p><strong>Segunda Fase:</strong></p>\n<p>Nessa fase daremos a tartaruga uma segunda chance, ou seja, diminuiremos a velocidade da lebre, de modo que agora ela se mova na velocidade da tartaruga: tortoise = nums[tortoise]\u00a0,hare = nums[hare]. A tartaruga est\u00e1 de volta \u00e0 posi\u00e7\u00e3o inicial e a lebre parte do ponto de interse\u00e7\u00e3o.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*p2uHTOH37bK6ma7QKYdw9w.png\"></figure><p>Mostraremos que desta vez eles se encontram na entrada do ciclo ap\u00f3s F\u00a0passos.</p>\n<ul>\n<li>A tartaruga come\u00e7ou em zero, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s o F passos \u00e9\u00a0F.</li>\n<li>A lebre come\u00e7ou no ponto de interse\u00e7\u00e3o F + a = nC, ent\u00e3o sua posi\u00e7\u00e3o ap\u00f3s F passos \u00e9 nC+F, o mesmo ponto que\u00a0F.</li>\n<li>Assim, a tartaruga e a lebre (desacelerada) se encontrar\u00e3o na entrada do\u00a0ciclo.</li>\n</ul>\n<p>A imagem abaixo mostra o que acontece durante todas as\u00a0fases.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/1*09n9E-RUgjCd6uIRzue7Gg.gif\"></figure><p>O c\u00f3digo em python \u00e9 escrito da seguinte\u00a0forma:</p>\n<pre>def findDuplicate(nums):<br>        # Ache o ponto de interse\u00e7\u00e3o dos ponteiros<br>        tortoise = hare = nums[0]<br>        while True:<br>            tortoise = nums[tortoise]<br>            hare = nums[nums[hare]]<br>            if tortoise == hare:<br>                break<br><br>        # Ache o a entrada dentro do ciclo.<br>        tortoise = nums[0]<br>        while tortoise != hare:<br>            tortoise = nums[tortoise]<br>            hare = nums[hare]<br><br>        return hare</pre>\n<ul>\n<li>\n<strong>Complexidade de tempo:</strong>\u00a0O(n)</li>\n<li>\n<strong>Complexidade no espa\u00e7o</strong>:\u00a0<em>O(1)</em>\n</li>\n</ul>\n<p>Aplicando esse m\u00e9todo temos uma solu\u00e7\u00e3o bem elegante e otimizada do nosso problema. Essa categoria de problema \u00e9 aquela que se torna trivial quando se resolve, mas num primeiro momento n\u00e3o \u00e9 intuitivo reduzi-lo em um problema de listas encadeada c\u00edclicas.</p>\n<p>Se houver d\u00favida ainda, \u00e9 poss\u00edvel printar no console os valores dos ponteiros tortoise e hare, para melhorar a visualiza\u00e7\u00e3o.</p>\n<h3>Referencias</h3>\n<ul>\n<li>Explica\u00e7\u00e3o em video pode ser vista\u00a0<a href=\"https://www.youtube.com/watch?v=wjYnzkAhcNk\">aqui</a>.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cycle_detection\">Wikipedia</a></li>\n<li>Problema pode se encontrado <a href=\"https://leetcode.com/problems/find-the-duplicate-number/\">aqui</a>.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=69ead8889a2f\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["leetcode","algorithms"]}]}